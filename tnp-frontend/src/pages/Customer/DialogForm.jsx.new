import { useState, useEffect, useCallback, useRef, useContext } from "react";
import { useSelector, useDispatch } from "react-redux";
import ScrollContext from "./ScrollContext";
import moment from "moment";
import Swal from "sweetalert2";

// Import existing dependencies and APIs
import {
  formatCustomRelativeTime,
  genCustomerNo,
} from "../../features/Customer/customerUtils";
import {
  setInputList,
  setItemList,
  resetInputList,
} from "../../features/Customer/customerSlice";
import {
  useAddCustomerMutation,
  useUpdateCustomerMutation,
} from "../../features/Customer/customerApi";
import { setLocationSearch } from "../../features/globalSlice";
import {
  useGetAllLocationQuery,
  useLazyGetAllLocationQuery,
  useGetUserByRoleQuery,
  useGetAllBusinessTypesQuery,
} from "../../features/globalApi";
import {
  open_dialog_ok_timer,
  open_dialog_error,
  open_dialog_loading,
} from "../../utils/import_lib";

// Import the new CustomerFormStepWizard component
import CustomerFormStepWizard from "./components/CustomerFormStepWizard";
import BusinessTypeManager from "../../components/BusinessTypeManager";

function DialogForm(props) {
  const dispatch = useDispatch();
  const user = JSON.parse(localStorage.getItem("userData"));
  const isAdmin = user.role === "admin";
  const inputList = useSelector((state) => state.customer.inputList);
  const itemList = useSelector((state) => state.customer.itemList);
  
  // Add auto-save timer state
  const [autoSaveTimer, setAutoSaveTimer] = useState(null);
  const [autoSavedAt, setAutoSavedAt] = useState(null);

  // Refs
  const formRef = useRef(null);
  const scrollRef = useRef(null);

  // Context
  const { scrollToTop } = useContext(ScrollContext);

  // API hooks
  const [addCustomer, { isLoading: isAddLoading }] = useAddCustomerMutation();
  const [updateCustomer, { isLoading: isUpdateLoading }] = useUpdateCustomerMutation();
  const {
    data: dataBt,
    isLoading: loadingBt,
    isError: errorBt,
  } = useGetAllBusinessTypesQuery();
  const {
    data: dataUser,
    isLoading: loadingUser,
    isError: errorUser,
  } = useGetUserByRoleQuery("all");
  const {
    data: dataLocation,
    isLoading: loadingLocation,
    isError: errorLocation,
  } = useGetAllLocationQuery();
  const [getLazyLocation, { isFetching }] = useLazyGetAllLocationQuery();
  const locationSearch = useSelector((state) => state.global.locationSearch);

  // States
  const [errors, setErrors] = useState({});
  const [showBusinessTypeManager, setShowBusinessTypeManager] = useState(false);
  const mode = props.mode || "add"; // add, edit, view

  // Create lists for form selections
  const userList = dataUser?.result || [];
  const businessTypeList = dataBt?.result || [];

  // Location data
  const provincesList = dataLocation?.province || [];
  const districtList = dataLocation?.district?.filter((item) => {
    if (locationSearch?.province_sort_id)
      return item.pro_id === locationSearch.province_sort_id;
    return inputList.cus_pv_id === item.pro_id;
  });
  const subDistrictList = dataLocation?.sub_district?.filter((item) => {
    if (locationSearch?.district_sort_id)
      return item.dis_id === locationSearch.district_sort_id;
    return inputList.cus_dis_id === item.dis_id;
  });

  // Set customer ID with a unique prefix for new customer
  useEffect(() => {
    if (mode === "add" && inputList.cus_id === undefined) {
      dispatch(
        setInputList({
          cus_id: genCustomerNo(),
          cus_create_by: user.id,
          cus_is_active: 1,
        })
      );
    }
  }, [dispatch, inputList.cus_id, mode, user]);

  // Check if form is being submitted
  const [isSubmitting, setIsSubmitting] = useState(false);
  const isLoading = isAddLoading || isUpdateLoading || isSubmitting;

  // Formatted time display for last update
  const lastUpdateTime = inputList.cd_last_datetime
    ? moment(inputList.cd_last_datetime).fromNow()
    : null;
  const formattedRelativeTime = lastUpdateTime
    ? formatCustomRelativeTime(lastUpdateTime)
    : "";

  // Map mode to Thai language for title
  const titleMap = {
    add: "เพิ่ม",
    edit: "แก้ไข",
    view: "ดู",
  };

  // Implement auto-save functionality
  const autoSaveForm = useCallback(() => {
    if (mode === "add" || mode === "edit") {
      // Save the current form state to localStorage
      localStorage.setItem("customerFormDraft", JSON.stringify({
        inputList,
        timestamp: new Date().toISOString(),
      }));
      setAutoSavedAt(new Date());
    }
  }, [inputList, mode]);

  // Handle input changes
  const handleInputChange = useCallback(
    (e) => {
      let { name, value } = e.target;
      
      // Clear previous auto-save timer
      if (autoSaveTimer) {
        clearTimeout(autoSaveTimer);
      }
      
      // Set new auto-save timer (2 seconds after last change)
      const newTimer = setTimeout(() => {
        autoSaveForm();
      }, 2000);
      
      setAutoSaveTimer(newTimer);

      // Clear error for the field being edited
      setErrors((prev) => ({ ...prev, [name]: "" }));

      let updatedInputList = {
        ...inputList,
        [name]: value,
      };

      // Handle location dropdown dependencies
      switch (name) {
        case "cus_pv_id": {
          // Clear dependent dropdowns
          updatedInputList.cus_dis_id = "";
          updatedInputList.cus_sub_id = "";
          updatedInputList.cus_zip_code = "";
          
          const provincesResult = provincesList.find(
            (find) => find.pro_id === value
          );
          if (provincesResult) {
            dispatch(
              setLocationSearch({
                province_sort_id: provincesResult.pro_sort_id,
              })
            );
          }
          break;
        }
        case "cus_dis_id": {
          // Clear dependent dropdowns
          updatedInputList.cus_sub_id = "";
          updatedInputList.cus_zip_code = "";
          
          const districtResult = districtList.find(
            (find) => find.dis_id === value
          );
          if (districtResult) {
            dispatch(
              setLocationSearch({
                ...locationSearch,
                district_sort_id: districtResult.dis_sort_id,
              })
            );
          }
          break;
        }
        case "cus_sub_id": {
          const subDistrictResult = subDistrictList.find(
            (find) => find.sub_id === value
          );
          if (subDistrictResult) {
            updatedInputList = {
              ...updatedInputList,
              cus_zip_code: subDistrictResult.sub_zip_code,
            };
          }
          break;
        }
        default:
          break;
      }

      dispatch(setInputList(updatedInputList));
    },
    [inputList, autoSaveTimer, autoSaveForm, dispatch, districtList, locationSearch, provincesList, subDistrictList]
  );

  // Handle location selection
  const handleSelectLocation = (field, value) => {
    handleInputChange({
      target: {
        name: field,
        value: value,
      },
    });
  };

  // Form validation
  const validateForm = () => {
    const newErrors = {};
    
    // Check required fields based on current tab
    const requiredFields = [
      "cus_company",
      "cus_name",
      "cus_tel_1",
      "cus_bt_id",
      "cus_channel"
    ];
    
    let isValid = true;
    
    requiredFields.forEach(field => {
      if (!inputList[field]) {
        newErrors[field] = `กรุณากรอก${field}`;
        isValid = false;
      }
    });
    
    setErrors(newErrors);
    return isValid;
  };

  // Handle form submission
  const handleSubmit = async (e) => {
    if (e) e.preventDefault();
    if (isSubmitting) return;

    // Validate form before submission
    if (!validateForm()) {
      return;
    }

    setIsSubmitting(true);
    
    // Show loading dialog
    open_dialog_loading("กำลังบันทึกข้อมูล...");

    try {
      // Prepare data
      const data = {
        ...inputList,
      };

      let result;
      
      if (mode === "add") {
        result = await addCustomer(data).unwrap();
      } else if (mode === "edit") {
        result = await updateCustomer(data).unwrap();
      }

      if (result.status === "ok") {
        // Show success dialog
        open_dialog_ok_timer("บันทึกข้อมูลสำเร็จ", "", 1000);
        
        // Clear draft from localStorage if exists
        localStorage.removeItem("customerFormDraft");
        
        // Close the dialog and refresh the data
        setTimeout(() => {
          props.handleCloseDialog();
          props.refreshData();
        }, 1000);
      } else {
        // Show error dialog
        open_dialog_error(result.message || "เกิดข้อผิดพลาดในการบันทึกข้อมูล");
      }
    } catch (error) {
      console.error("Submit Error:", error);
      open_dialog_error(error?.data?.message || "เกิดข้อผิดพลาดในการบันทึกข้อมูล");
    } finally {
      setIsSubmitting(false);
    }
  };

  // Load auto-saved draft
  useEffect(() => {
    if (mode === "add") {
      const savedDraft = localStorage.getItem("customerFormDraft");
      
      if (savedDraft) {
        try {
          const { inputList: savedInputList, timestamp } = JSON.parse(savedDraft);
          const savedTime = moment(timestamp);
          // Only load drafts that are less than 24 hours old
          if (moment().diff(savedTime, 'hours') < 24) {
            // Ask user if they want to load the draft
            Swal.fire({
              title: 'พบข้อมูลที่บันทึกไว้',
              text: `คุณต้องการโหลดข้อมูลที่บันทึกไว้เมื่อ ${savedTime.format('DD/MM/YYYY HH:mm')} หรือไม่?`,
              icon: 'question',
              showCancelButton: true,
              confirmButtonColor: '#3085d6',
              cancelButtonColor: '#d33',
              confirmButtonText: 'ใช่, โหลดข้อมูล',
              cancelButtonText: 'ไม่, เริ่มใหม่'
            }).then((result) => {
              if (result.isConfirmed) {
                dispatch(setInputList(savedInputList));
                setAutoSavedAt(new Date(timestamp));
              }
            });
          }
        } catch (error) {
          console.error("Error loading draft:", error);
        }
      }
    }
  }, [dispatch, mode]);

  return (
    <>
      {/* Business Type Manager Dialog */}
      {showBusinessTypeManager && (
        <BusinessTypeManager
          openDialog={showBusinessTypeManager}
          handleCloseDialog={() => setShowBusinessTypeManager(false)}
        />
      )}
      
      {/* Customer Form Step Wizard - New component */}
      <CustomerFormStepWizard
        openDialog={props.openDialog}
        handleCloseDialog={props.handleCloseDialog}
        inputList={inputList}
        errors={errors}
        mode={mode}
        handleInputChange={handleInputChange}
        handleSelectLocation={handleSelectLocation}
        handleSubmit={handleSubmit}
        isLoading={isLoading}
        provincesList={provincesList}
        districtList={districtList}
        subDistrictList={subDistrictList}
        isFetching={isFetching}
      />
    </>
  );
}

export default DialogForm;
